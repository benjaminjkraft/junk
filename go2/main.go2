package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/benjaminjkraft/junk/go2/result"
	"golang.org/x/sync/errgroup"
)

func bytestoi(b []byte) result.Result(int) {
	return result.NewResult(strconv.Atoi(string(b)))
}

func resultTypes() {
	b := strings.NewReader("10")
	// bytestoi(ioutil.ReadAll(b)), with error handling
	i, err := result.Lift(bytestoi)(
		result.Func(ioutil.ReadAll)(
			b)).Unwrap()

	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(i)
}

func ParallelMap(type T, U)(ctx context.Context, f func(context.Context, T) (U, error), ts []T) ([]U, error) {
	eg, ctx := errgroup.WithContext(ctx)
	results := make([]U, len(ts)) // only assign index for thread-safety
	for i, t := range ts {
		i, t := i, t // bind loop variants for goroutine
		eg.Go(func() error {
			u, err := f(ctx, t)
			if err != nil {
				return err
			}
			results[i] = u
			return err
		})
	}
	return results, eg.Wait()

}

func getresponse(ctx context.Context, req *http.Request) ([]byte, error) {
	fmt.Printf("making request to %v\n", req.URL)
	defer fmt.Printf("completed request to %v\n", req.URL)

	resp, err := http.DefaultClient.Do(req.WithContext(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("bad status %v", resp.StatusCode)
	}

	return ioutil.ReadAll(resp.Body)
}

func Map(type T1, T2)(s []T1, f func(T1) T2) []T2 {
	r := make([]T2, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}

func MapErr(type T1, T2)(s []T1, f func(T1) (T2, error)) ([]T2, error) {
	r := make([]T2, len(s))
	for i, v := range s {
		var err error
		r[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return r, nil
}

func str(b []byte) string { return string(b) }

func httpReqs() {
	reqs, err := MapErr([]string{"www.khanacademy.org", "google.com", "en.wikipedia.org"},
		func(domain string) (*http.Request, error) {
			return http.NewRequest("GET", "https://"+domain+"/robots.txt", nil)
		})
	if err != nil {
		fmt.Println(err)
		return
	}

	resps, err := ParallelMap(context.Background(), getresponse, reqs)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(Map(resps, str))
}

func main() {
	resultTypes()
	httpReqs()
}
